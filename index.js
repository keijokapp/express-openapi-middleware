const Validator = require('jsonschema').Validator;


/**
 * OpenAPI request validation error
 */
class OpenAPIValidation extends Error {
	constructor(validations) {
		super();
		this.name = 'OpenAPIValidation';
		this.nessage = 'express-openapi-middleware: Invalid data found';
		this.validations = validations;
	}
}


/**
 * Transforms regular expression generated
 * by 'path-to-regexp' to OpenAPI-compatible path
 * @param regexp {RegExp} regular expression to be transformed
 * @param keys {string[]} placeholders generated by 'path-to-regexp'
 * @returns {string} OpenaPI-compatible path
 */
function regexpToPath(regexp, keys = []) {

	// cut off '^'
	regexp = regexp.source.slice(1);

	// unescape some characters
	regexp = regexp.replace(/\\([./])/g, '$1');

	// determine and cut off ending
	if(regexp.endsWith('/?$')) {
		regexp = regexp.slice(0, -3);
	} else if(regexp.endsWith('/?(?=/|$)')) {
		regexp = regexp.slice(0, -9);
	} else {
		throw new Error('Bad input: Cannot determine ending');
	}

//	if(!regexp) {
//		return '/';
//	}

	let scanIndex = 0;
	let captureIndex = 0;
	const components = [];

	while(scanIndex < regexp.length) {
		if(regexp.startsWith('/(?:([^/]+?))', scanIndex)) {
			scanIndex += 13;
			if(!(captureIndex in keys)) {
				throw new Error('Bad input: Unexpected capture group at position ' + scanIndex);
			}
			// TODO: optional and repeated parameters
			components.push('/{' + keys[captureIndex++].name + '}');
		} else if(regexp.startsWith('/', scanIndex)) {
			let nextSlash = regexp.indexOf('/', scanIndex + 1);
			if(nextSlash === -1) {
				components.push(regexp.slice(scanIndex));
				break;
			} else {
				components.push(regexp.slice(scanIndex, nextSlash));
				scanIndex = nextSlash;
			}
		} else {
			throw new Error('Bad input: Unexpected character "' + regexp[scanIndex] + "' at position " + scanIndex);
		}
	}

	return components.join('');
}


/**
 * Iterates through all layers in router
 * @param router {Router}
 * @param out {object}
 * @param routePrefix {string}
 * @param middlewares {function[]}
 */
function iterateRouter(router, out, routePrefix = '', middlewares = []) {
	for(const layer of router.stack) {
		let path;
		try {
			path = routePrefix + regexpToPath(layer.regexp, layer.keys);
		} catch(e) {
			// ignored silently
			continue;
		}
		if(layer.route) {
			if(!(path in out)) {
				out[path] = {};
			}
			for(const routeLayer of layer.route.stack) {
				const method = routeLayer.method;
				if(!(method in out[path])) {
					out[path][method] = middlewares.slice();
				}
				out[path][method].push(routeLayer.handle);
			}
		} else if(layer.name === 'router') {
			iterateRouter(layer.handle, out, path, middlewares);
		} else {
			middlewares = middlewares.concat([layer.handle]);
		}
	}
}


/**
 * Creates middleware representing
 * OpenAPI operation
 * @param operation {object} OpenAPI operation object
 * @returns {function} Middleware function
 */
function apiOperation(operation) {
	const validator = new Validator();

	const sources = {
		header: 'headers',
		path: 'params',
		query: 'query',
		cookie: 'cookies'
	};

	const middleware = function(req, res, next) {
		req.apiOperation = operation;
		const validations = [];
		if('parameters' in operation) {
			for(const parameter of operation.parameters) {
				const parameterName = parameter.name;
				const parameterSource = sources[parameter.in];
				if(parameterSource && parameterSource in req && parameterName in req[parameterSource]) {
					if('schema' in parameter) {
						const validationResult = validator.validate(req[parameterSource][parameterName], parameter.schema, {
							nestedErrors: true,
							propertyName: parameter.name
						});
						if(!validationResult.valid) {
							delete validationResult.disableFormat;
							validations.push({parameter, validation: validationResult});
						}
					}
				} else if(parameter.required) {
					validations.push({parameter, validation: 'missing'});
				}
			}
		}

		if('requestBody' in operation) {
			if('body' in req) {
				if('content' in operation.requestBody && 'application/json' in operation.requestBody.content && 'schema' in operation.requestBody.content['application/json']) {
					const validationResult = validator.validate(req.body, operation.requestBody.content['application/json'].schema, {
						nestedErrors: true,
						propertyName: 'body'
					});
					if(!validationResult.valid) {
						delete validationResult.disableFormat;
						validations.push({ parameter: operation.requestBody, validation: validationResult });
					}
				}
			} else if(operation.requestBody.required) {
				validations.push({ parameter: operation.requestBody, validation: 'missing' });
			}
		}

		if(Object.keys(validations).length) {
			next(new OpenAPIValidation(validations));
		} else {
			next();
		}

	};
	middleware.apiOperation = operation;

	return middleware;
}


/**
 * Merges two operation objects
 * @param spec {object}
 * @param moreSpec {object}
 * @returns {object}
 */
function mergeOperationObjects(spec, moreSpec) {
	const mergedSpec = Object.assign({}, spec, moreSpec);

	if('tags' in moreSpec) {
		mergedSpec.tags = 'tags' in spec
			? spec.tags.concat(moreSpec.tags)
			: moreSpec.tags;
	}

	if('parameters' in moreSpec) {
		mergedSpec.parameters = 'parameters' in spec
			? spec.parameters.concat(moreSpec.parameters)
			: moreSpec.parameters;
	}

	if('responses' in moreSpec) {
		mergedSpec.responses = Object.assign({}, spec.responses, moreSpec.responses);
	}

	return mergedSpec;
}


/**
 * Iterates through all routes in router
 * looking for OpenAPI middlewares
 * and creates OpenAPI paths object
 * @param router {Router} Express-compatible router
 * @returns {object} OpenAPI paths object
 */
function createPaths(router) {
	const paths = {};
	const routes = {};
	iterateRouter(router, routes);
	for(let path in routes) {
		if(routes.hasOwnProperty(path)) {
			for(const method in routes[path]) {
				if(routes[path].hasOwnProperty(method)) {
					for(const middleware of routes[path][method]) {
						if('apiOperation' in middleware) {
							if(!path) {
								path = '/';
							}
							if(!(path in paths)) {
								paths[path] = {};
							}
							if(method in paths[path]) {
								paths[path][method] = mergeOperationObjects(paths[path][method], middleware.apiOperation);
							} else {
								paths[path][method] = middleware.apiOperation;
							}
						}
					}
				}
			}
		}
	}

	return paths;
}


module.exports = {
	apiOperation,
	createPaths
};
